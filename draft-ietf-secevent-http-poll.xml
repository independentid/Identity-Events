<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='http://xml2rfc.tools.ietf.org/authoring/rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" docName="draft-ietf-secevent-http-poll-03"
	ipr="trust200902">
  <front>
    <title abbrev="draft-ietf-secevent-http-poll">
			Poll-Based Security Event Token (SET) Delivery Using HTTP</title>

    <author fullname="Annabelle Backman" initials="A." surname="Backman" role="editor">
      <organization abbrev="Amazon">Amazon</organization>
      <address>
        <email>richanna@amazon.com</email>
      </address>
    </author>

    <author fullname="Michael B. Jones" initials="M." surname="Jones" role="editor">
        <organization abbrev="Microsoft">Microsoft</organization>
        <address>
            <email>mbj@microsoft.com</email>
            <uri>http://self-issued.info/</uri>
        </address>
    </author>

    <author fullname="Marius Scurtescu" initials="M.S." surname="Scurtescu">
      <organization abbrev="Coinbase">Coinbase</organization>

      <address>
        <email>marius.scurtescu@coinbase.com</email>
      </address>
    </author>

    <author fullname="Morteza Ansari" initials="M." surname="Ansari">
      <organization abbrev="Cisco">Cisco</organization>

      <address>
        <email>morteza.ansari@cisco.com</email>
      </address>
    </author>

    <author fullname="Anthony Nadalin" initials="A." surname="Nadalin">
      <organization abbrev="Microsoft">Microsoft</organization>

      <address>
        <email>tonynad@microsoft.com</email>
      </address>
    </author>

    <date year="2019" month="July" day="8" />

    <keyword>Internet-Draft</keyword>

    <abstract>
      <t>
	This specification defines how a series of Security Event Tokens
        (SETs) may be delivered to an intended recipient
        using HTTP POST over TLS initiated as a poll by the recipient. The
        specification also defines how delivery can be assured, subject to
        the SET Recipient's need for assurance.
        </t>
    </abstract>
  </front>

  <middle>
    <section anchor="intro" title="Introduction and Overview" toc="default">

      <t>
        This specification defines how a stream of
	Security Event Tokens (SETs) <xref target="RFC8417"/>
        can be transmitted to an intended
        SET Recipient using HTTP <xref target="RFC7231"/>
        over TLS. The specification defines a method to poll for SETs
        using HTTP POST.
      </t>
      <t>
	A mechanism for exchanging configuration metadata such as endpoint URLs
	and cryptographic key parameters between the transmitter and recipient is
	out of scope for this specification.
      </t>

      <section anchor="notat" title="Notational Conventions" toc="default">
	<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
	NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
	"MAY", and "OPTIONAL" in this document are to be interpreted as
	described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
	when, and only when, they appear in all capitals, as shown here.
	</t>

	<t>Throughout this document, all figures MAY contain spaces and
	extra
	line wrapping for readability and due to space limitations.
	</t>
      </section>

      <section anchor="defs" title="Definitions" toc="default">
	<t>
            This specification utilizes terminology defined in <xref target="RFC8417"/>
            and <xref target="I-D.ietf-secevent-http-push"/>.
	</t>
      </section>
    </section>

    <section title="SET Delivery">
      <t>
	When an event occurs, the SET Transmitter constructs a SET
	<xref target="RFC8417"/> that describes the	
	event. The SET Transmitter determines the SET Recipients that the
	SET should be distributed to.
      </t>
      <t>
	How SETs are defined and the process by which events are identified for
	SET Recipients is out of scope of this specification.
      </t>

      <t>
	When a SET is available for a SET Recipient, the SET Transmitter
	attempts to deliver the SET 
	by queueing the SET in a buffer so that
	a SET Recipient can poll for SETs using HTTP/1.1 POST.
      </t>

      <t>
	In Poll-Based SET Delivery Using HTTP, zero or more SETs are
        delivered in a JSON <xref target="RFC8259"/> document
        to a SET Recipient in response to an HTTP POST request to the
        SET Transmitter. Then in a following request, the SET Recipient
        acknowledges received SETs and can poll for more.  All requests and
        responses are JSON documents and use a
        <spanx style="verb">Content-Type</spanx> of
        <spanx style="verb">application/json</spanx>, as described in
        <xref target="httpPoll"/>.
      </t>

      <t>After successful (acknowledged) SET delivery, SET
      Transmitters are not be required to retain or record SETs for
      retransmission. Once a SET is acknowledged, the SET Recipient SHALL be
      responsible for retention, if needed.</t>

      <t>Transmitted SETs SHOULD be self-validating (signed)
      if there is a requirement to verify they were issued by the SET
      Transmitter at a later date when de-coupled from the original
      delivery where authenticity could be checked via the HTTP or
      TLS mutual authentication.
      </t>

      <t>
	Upon receiving a SET, the SET Recipient reads the SET and validates
	it in the manner described in Section 2 of <xref target="I-D.ietf-secevent-http-push"/>.
	The SET Recipient MUST acknowledge receipt to the SET Transmitter.
	The SET Recipient SHALL NOT use the event acknowledgement mechanism
	to report event errors other than relating to the parsing and validation
	of the SET.
      </t>

      <section anchor="httpPoll" title="Polling Delivery using HTTP">
	
	<t>This method allows a SET Recipient to use HTTP POST
	(Section 4.3.3 of <xref target="RFC7231"/>) to acknowledge
	SETs and to check for and receive zero or more SETs. Requests
	MAY be made at a periodic interval (short polling) or requests
	MAY wait, pending availability of new SETs using long polling,
	per Section 2 of <xref target="RFC6202"/>.</t>
	
	<t>The delivery of SETs in this method is facilitated by HTTP
	POST requests initiated by the SET Recipient in which:<list style="symbols">
        <t>The SET Recipient makes a request for available SETs
        using an HTTP POST to a pre-arranged endpoint provided by the SET
        Transmitter or,</t>
        <t>after validating previously received SETs, the SET Recipient
        initiates another poll request using HTTP POST that includes
        acknowledgement of previous SETs and waits for the next batch
        of SETs.</t>
	</list></t>
	
	<t>The purpose of the acknowledgement is to inform the
	SET Transmitter that delivery has succeeded and
	redelivery is no longer required. Before acknowledgement, SET
	Recipients SHOULD ensure that received SETs have been validated and
	retained in a manner appropriate to the recipient's
	requirements. The level and method of retention of SETs
	by SET Recipients is out of scope of this specification.</t>
      </section>

      <section anchor="pollReq" title="Polling HTTP Request">

	<t>When initiating a poll request, the SET Recipient constructs
	a JSON document that consists of polling request parameters
	and SET acknowledgement parameters in the form of JSON objects.
	The request payloads are delivered in a JSON document, as described
	in <xref target="pollRequest"/> and <xref target="pollGetAck"/>.
	</t>
	
	<t>When making a request, the HTTP header <spanx style="verb">Content-Type</spanx>
	is set to <spanx style="verb">application/json</spanx>.</t>
	
	<t>The following JSON object members are used in a polling request:
	<list style="hanging">
	
	  <t hangText="Request Processing Parameters"><list style="hanging">
	
	    <t hangText="maxEvents"><vspace/>An OPTIONAL JSON integer value
	    indicating the maximum number of unacknowledged SETs that
	    SHOULD be returned. If more than the maximum number of SETs
	    are available, the oldest SETs available SHOULD be returned
	    first. A value of <spanx style="verb">0</spanx> MAY be used by
	    SET Recipients that would like to perform an acknowledge only
	    request. This enables the Recipient to use separate HTTP requests
	    for acknowledgement and reception of SETs.
	    If this parameter is omitted, no limit is placed on
	    the number of SETs to be returned.
	    </t>
	
	    <t hangText="returnImmediately"><vspace/>An OPTIONAL JSON
	    boolean value that indicates the SET Transmitter SHOULD return
	    an immediate response even if no results are available
	    (short polling). The default value is <spanx style="verb">false</spanx>,
	    which indicates the request is to be treated as an HTTP Long Poll,
	    per Section 2 of <xref target="RFC6202"/>. The timeout for the
	    request is part of the configuration between the participants, which is out of
	    scope of this specification.</t>

	  </list></t>

         <t hangText="SET Acknowledgment Parameters"><list style="hanging">

	   <t hangText="ack"><vspace/>An array of strings that each
	   corresponds to the <spanx style="verb">jti</spanx> of a
	   successfully received SET. If there are no
	   outstanding SETs to acknowledge, the member MAY be omitted.
	   When acknowledging a SET, the SET Transmitter is released from
	   any obligation to retain the SET.</t>
	
	   <t hangText="setErrs"><vspace/>A JSON Object that contains
	   one or more nested JSON object members that correspond to the
	   <spanx style="verb">jti</spanx> of each invalid SET received.
	   The value of each is a JSON object whose contents is an
	   <spanx style="verb">err</spanx> member and
	   <spanx style="verb">description</spanx> member, whose values
	   correspond to the errors described in <xref target="errorResponse"/>.</t>

         </list></t>
	
        </list>
        </t>
      </section>

      <section anchor="pollResp" title="Polling HTTP Response">

	<t>In response to a poll request, the SET Transmitter checks for
	available SETs and responds with a JSON document containing
	the following JSON object members:
	<list style="hanging">
	
	  <t hangText="sets"><vspace/>A JSON object that contains zero
	  or more nested JSON objects. Each nested JSON object
	  corresponds to the <spanx style="verb">jti</spanx> of a SET to
	  be delivered and whose value is a JSON string containing the
	  value of the encoded corresponding SET. If there are no
	  outstanding SETs to be transmitted, the JSON object SHALL be
	  empty.</t>
	
	  <t hangText="moreAvailable"><vspace/>A JSON boolean value that
	  indicates if more unacknowledged SETs are available to be returned.
	  </t>
	</list>
	</t>
	
	<t>When making a response, the HTTP header <spanx style="verb">Content-Type</spanx>
	is set to <spanx style="verb">application/json</spanx>.</t>
      </section>

      <section anchor="pollRequest" title="Poll Request">

	<t>The SET Recipient performs an HTTP POST (see
	Section 4.3.4 of <xref target="RFC7231"/>) to a pre-arranged
	polling endpoint URI to check for SETs that are available.
	Because the SET Recipient has no prior SETs to
	acknowledge, the <spanx style="verb">ack</spanx> and
	<spanx style="verb">errs</spanx> request parameters are omitted.</t>

	<t>If after a period of time, negotiated between the SET
	Transmitter and Recipient, a SET Transmitter MAY redeliver SETs
	it has previously delivered. The SET Recipient SHOULD accept
	repeat SETs and acknowledge the SETs regardless of whether the
	Recipient believes it has already acknowledged the SETs previously.
	A SET Transmitter MAY limit the number of times it attempts to
	deliver a SET.
	</t>
	
        <t>If the SET Recipient has received SETs from the
        SET Transmitter, the SET Recipient SHOULD parse and validate
        received SETs to meet its own requirements and SHOULD acknowledge
        receipt in a timely fashion (e.g., seconds or minutes) so that the SET
        Transmitter can mark the SETs as received. SET Recipients SHOULD
        acknowledge receipt before taking any local actions based on
        the SETs to avoid unnecessary delay in acknowledgement, where
        possible.</t>

        <t>Poll requests have three variations:
        <list style="hanging">
          <t hangText="Poll Only"><vspace/>In which a SET Recipient
          asks for the next set of events where no previous SET deliveries
          are acknowledged (such as in the initial poll request).</t>
          <t hangText="Acknowledge Only"><vspace/>In which a SET
          Recipient sets the <spanx style="verb">maxEvents</spanx>
          value to <spanx style="verb">0</spanx> along with
          <spanx style="verb">ack</spanx> and
          <spanx style="verb">err</spanx> members indicating the
          SET Recipient is acknowledging previously received SETs and
          does not want to receive any new SETs in response to the
          request. </t>
          <t hangText="Combined Acknowledge and Poll"><vspace/>In
          which a SET Recipient is both acknowledging previously
          received SETs using the <spanx style="verb">ack</spanx> and
          <spanx style="verb">err</spanx> members
          and will wait for the next group of SETs in the SET Transmitters
          response.</t>
        </list></t>

	<section title="Poll Only Request">
	  <t>In the case where no SETs were received in a previous poll (see
	  <xref target="emptyPollResponse"/>), the SET Recipient simply
	  polls without acknowledgement parameters (<spanx style="verb">sets</spanx>
	  and <spanx style="verb">setErrs</spanx>).</t>

	  <t></t>
	
	  <figure anchor="pollInitRequest" title="Example Initial Poll Request">
	    <preamble>
	      The following is an example request made by a SET Recipient
	      that has no outstanding SETs to acknowledge and is polling
	      for available SETs at the endpoint
	      <spanx style="verb">https://nofity.exampleidp.com/Events</spanx>:
	    </preamble>
	    <artwork align="left">POST /Events HTTP/1.1

Host: notify.exampleidp.com
Authorization: Bearer h480djs93hd8
Accept: application/json

{
 "returnImmediately": true
}</artwork>
	  </figure>

	  <t>A SET Recipient can poll using default parameter values by passing
	  an empty JSON object.</t>
	
	  <figure anchor="pollDefaultRequest" title="Example Default Poll Request">
	    <preamble>The following is a non-normative example default poll request to the
	    endpoint <spanx style="verb">https://nofity.exampleidp.com/Events</spanx>:</preamble>
	    <artwork align="left">POST /Events HTTP/1.1

Host: notify.exampleidp.com
Authorization: Bearer h480djs93hd8
Accept: application/json

{}</artwork>
	  </figure>
	</section>
	
	<section title="Acknowledge Only Request">
	  <t>In this variation, the SET Recipient acknowledges previously
	  received SETs and indicates it does not want to receive SETs in
	  response by setting the <spanx style="verb">maxEvents</spanx>
	  value to <spanx style="verb">0</spanx>.</t>
	
	  <t>This variation might be used, for instance, when a SET Recipient needs to
	  acknowledge received SETs independently (e.g., on separate threads)
	  from the process of receiving SETs.</t>
	
	  <figure anchor="pollAckOnly" title="Example Acknowledge Only Request">
	    <preamble>The following is a non-normative example poll request with acknowledgement
	    of SETs received (for example as shown in
	    <xref target="pollResponse"/>):</preamble>
	    <artwork>POST /Events HTTP/1.1

Host: notify.exampleidp.com
Authorization: Bearer h480djs93hd8
Content-Type: application/json
Authorization: Bearer h480djs93hd8

{
  "ack": [
    "4d3559ec67504aaba65d40b0363faad8",
    "3d0c3cf797584bd193bd0fb1bd4e7d30"
  ],
  "maxEvents": 0,
  "returnImmediately": true
}</artwork>
	  </figure>
	</section>

	<section anchor="pollAck" title="Poll with Acknowledgement">
	
	  <t>This variation allows a recipient thread to simultaneously
	  acknowledge previously received SETs and wait for the next
	  group of SETs in a single request.</t>
	
	  <figure anchor="pollGoodResponse" title="Example Poll with Acknowledgement and No Errors">
	    <preamble>The following is a non-normative example poll with acknowledgement
	    of the SETs received in <xref target="pollResponse"/>:</preamble>
	    <artwork>POST /Events HTTP/1.1

Host: notify.exampleidp.com
Authorization: Bearer h480djs93hd8
Content-Type: application/json
Authorization: Bearer h480djs93hd8

{
  "ack": [
    "4d3559ec67504aaba65d40b0363faad8",
    "3d0c3cf797584bd193bd0fb1bd4e7d30"
  ],
  "returnImmediately": false
}</artwork>
	  </figure>

	  <t>In the above acknowledgement, the SET Recipient has acknowledged
	  receipt of two SETs and has indicated it wants to wait until
	  the next SET is available.</t>
	</section>
	
	<section anchor="pollAckErr" title="Poll with Acknowledgement and Errors">
	  <t>In the case where errors were detected in previously
	  delivered SETs, the SET Recipient MAY use the
	  <spanx style="verb">setErrs</spanx> member to communicate the errors
	  in the following poll request.
	  </t>
	
	  <figure anchor="pollErrorResponse"
		  title="Example Poll Acknowledgement with Error">
	    <preamble>The following is a non-normative example of a response
	    acknowledging one successfully received SET and one SET with an error
	    from the two SETs received in <xref target="pollResponse"/>:</preamble>
	    <artwork>POST /Events HTTP/1.1

Host: notify.exampleidp.com
Authorization: Bearer h480djs93hd8
Content-Type: application/json
Authorization: Bearer h480djs93hd8

{
  "ack": ["3d0c3cf797584bd193bd0fb1bd4e7d30"],
  "setErrs": {
    "4d3559ec67504aaba65d40b0363faad8": {
      "err": "jwtAud",
      "description": "The audience value was invalid."
    }
  },
  "returnImmediately": true
}</artwork>
	  </figure>

	</section>
      </section>

      <section anchor="pollGetAck"
	       title="Poll Response">

	<t>In response to a poll request, the service provider MAY
	respond immediately if SETs are available to be delivered.
	If no SETs are available at the time of the request, the
	SET Transmitter SHALL delay responding until a SET is
	available or the timeout interval has elapsed unless the poll request parameter
	<spanx style="verb">returnImmediately</spanx> is <spanx style="verb">true</spanx>.</t>
	
	<t>As described in <xref target="pollResp"/>, a JSON document
	is returned containing a number of members including
	<spanx style="verb">sets</spanx>, which SHALL contain zero or more
	SETs.</t>
	<figure anchor="pollResponse" title="Example Poll Response">
	  <preamble>The following is a non-normative example response to
	  the request shown in <xref target="pollRequest"/>. This example
	  shows two SETs being returned:</preamble>
	  <artwork align="left">HTTP/1.1 200 OK
Content-Type: application/json
Location: https://notify.exampleidp/Events

{
"sets": {
  "4d3559ec67504aaba65d40b0363faad8":
   "eyJhbGciOiJub25lIn0.
   eyJqdGkiOiI0ZDM1NTllYzY3NTA0YWFiYTY1ZDQwYjAzNjNmYWFkOCIsImlhdCI6MTQ
   1ODQ5NjQwNCwiaXNzIjoiaHR0cHM6Ly9zY2ltLmV4YW1wbGUuY29tIiwiYXVkIjpbIm
   h0dHBzOi8vc2NpbS5leGFtcGxlLmNvbS9GZWVkcy85OGQ1MjQ2MWZhNWJiYzg3OTU5M
   2I3NzU0IiwiaHR0cHM6Ly9zY2ltLmV4YW1wbGUuY29tL0ZlZWRzLzVkNzYwNDUxNmIx
   ZDA4NjQxZDc2NzZlZTciXSwiZXZlbnRzIjp7InVybjppZXRmOnBhcmFtczpzY2ltOmV
   2ZW50OmNyZWF0ZSI6eyJyZWYiOiJodHRwczovL3NjaW0uZXhhbXBsZS5jb20vVXNlcn
   MvNDRmNjE0MmRmOTZiZDZhYjYxZTc1MjFkOSIsImF0dHJpYnV0ZXMiOlsiaWQiLCJuY
   W1lIiwidXNlck5hbWUiLCJwYXNzd29yZCIsImVtYWlscyJdfX19.",
  "3d0c3cf797584bd193bd0fb1bd4e7d30":
   "eyJhbGciOiJub25lIn0.
   eyJqdGkiOiIzZDBjM2NmNzk3NTg0YmQxOTNiZDBmYjFiZDRlN2QzMCIsImlhdCI6MTQ
   1ODQ5NjAyNSwiaXNzIjoiaHR0cHM6Ly9zY2ltLmV4YW1wbGUuY29tIiwiYXVkIjpbIm
   h0dHBzOi8vamh1Yi5leGFtcGxlLmNvbS9GZWVkcy85OGQ1MjQ2MWZhNWJiYzg3OTU5M
   2I3NzU0IiwiaHR0cHM6Ly9qaHViLmV4YW1wbGUuY29tL0ZlZWRzLzVkNzYwNDUxNmIx
   ZDA4NjQxZDc2NzZlZTciXSwic3ViIjoiaHR0cHM6Ly9zY2ltLmV4YW1wbGUuY29tL1V
   zZXJzLzQ0ZjYxNDJkZjk2YmQ2YWI2MWU3NTIxZDkiLCJldmVudHMiOnsidXJuOmlldG
   Y6cGFyYW1zOnNjaW06ZXZlbnQ6cGFzc3dvcmRSZXNldCI6eyJpZCI6IjQ0ZjYxNDJkZ
   jk2YmQ2YWI2MWU3NTIxZDkifSwiaHR0cHM6Ly9leGFtcGxlLmNvbS9zY2ltL2V2ZW50
   L3Bhc3N3b3JkUmVzZXRFeHQiOnsicmVzZXRBdHRlbXB0cyI6NX19fQ."
 }
}</artwork>
	</figure>
	<t>In the above example, two SETs whose <spanx style="verb">jti</spanx> values
	are <spanx style="verb">4d3559ec67504aaba65d40b0363faad8</spanx>
	and <spanx style="verb">3d0c3cf797584bd193bd0fb1bd4e7d30</spanx>
	are delivered.</t>
	
	<figure anchor="emptyPollResponse" title="Example No SETs Poll Response">
	  <preamble>The following is a non-normative example response to
	  the request shown in <xref target="pollRequest"/>, which indicates that no new
	  SETs or unacknowledged SETs are available:</preamble>
	  <artwork align="left">HTTP/1.1 200 OK
Content-Type: application/json
Location: https://notify.exampleidp/Events

{
 "sets": {}
}</artwork>
	</figure>
	
	<t>Upon receiving the JSON document (e.g., as shown in
	<xref target="pollResponse"/>), the SET Recipient parses
	and verifies the received SETs and notifies the SET Transmitter
	via the next poll request to the SET Transmitter, as described in
	<xref target="pollAck"/> or <xref target="pollAckErr"/>.</t>
	
      </section>

      <section anchor="errorResponse" title="Error Response Handling">
        <t>
	  If a SET is invalid,
	  error codes from the IANA "Security Event Token Delivery Error Codes"
	  registry established by <xref target="I-D.ietf-secevent-http-push"/>
	  are used in error responses.
	  As described in Section 2.3 of <xref target="I-D.ietf-secevent-http-push"/>,
	  an error response is a JSON object providing details about the error
	  that includes the following name/value pairs:
	</t>
	<t>
	  <list style="hanging">
	    <t hangText="err"><vspace />
	      A value from the
	      IANA "Security Event Token Delivery Error Codes" registry
	      that identifies the error.
	    </t>
	    <t hangText="description"><vspace />
	      A human-readable string that provides
	      additional diagnostic information.
	    </t>
	  </list>
	</t>
	<t>
	  When included as part of a batch of SETs, the above JSON is included
	  as part of the <spanx style="verb">setErrs</spanx> member, as
          defined in <xref target="pollResp"/> and <xref target="pollAckErr"/>.
	</t>
      </section>

    </section>

    <section anchor="aa" title="Authentication and Authorization" toc="default">
      <t>The SET delivery method described in this specification is
      based upon HTTP and depends on the use of TLS and/or standard
      HTTP authentication and authorization schemes, as per
      <xref target="RFC7235" />. For example, the following
      methodologies could be used among others: <list style="hanging">
      <t hangText="TLS Client Authentication"><vspace />Event delivery
      endpoints MAY request TLS mutual client authentication,
      per Section 7.3 of <xref target="RFC5246"/>. </t>

      <t hangText="Bearer Tokens"><vspace />Bearer tokens
      <xref target="RFC6750" /> MAY be used when combined with TLS and a token
      framework such as OAuth 2.0 <xref target="RFC6749" />.
      For security considerations regarding the use of bearer tokens in
      SET delivery, see <xref target="bearerConsiderations" />.</t>

      <t hangText="Basic Authentication"><vspace />Use of HTTP BASIC
      authentication should be avoided due to its use of a single factor
      that is based upon a relatively static, symmetric secret.
      When used, implementers SHOULD combine the use of basic authentication with
      other factors. The security considerations of HTTP BASIC are well
      documented in <xref target="RFC7617" /> and SHOULD be considered
      along with using signed SETs,
      as described in <xref target="payloadAuthentication"/>.
      </t>
      </list></t>

      <t>As per Section 4.1 of <xref target="RFC7235"/>, a SET
      delivery endpoint SHALL indicate supported HTTP authentication
      schemes via the <spanx style="verb">WWW-Authenticate</spanx> header.</t>

      <t>
	Authorization for the ability to pick-up or deliver SETs can be determined by
	using the identity of the SET issuer, or via an authentication
      method above. This specification considers authentication as a
      feature to prevent denial-of-service attacks. Because SETs are
      not commands, SET Recipients are free to ignore SETs that
      are not of interest after acknowledging their receipt.</t>

      <t>For illustrative purposes only, SET delivery examples show an OAuth 2.0
      bearer token value <xref target="RFC6750" /> in the authorization header.
      This is not intended to imply that bearer tokens are
      preferred. However, the use of bearer tokens in the specification does
      reflect common practice. </t>

      <section anchor="authzTokens" title="Use of Tokens as Authorizations">
        <t>When using bearer tokens or proof-of-possession tokens that
        represent an authorization grant such as issued by OAuth (see <xref target="RFC6749" />), implementers SHOULD consider the type of
        authorization granted, any authorized scopes (see Section 3.3 of <xref target="RFC6749" />), and the security subject(s) that SHOULD be mapped
        from the authorization when considering local access control rules.
        Section 6 of the OAuth Assertion Framework specification <xref target="RFC7521" />
	documents common scenarios for
        authorization including:<list style="symbols">
            <t>Clients using an assertion to authenticate and/or act on behalf
            of itself;</t>

            <t>Clients acting on behalf of a user; and,</t>

            <t>A Client acting on behalf of an anonymous user.</t>

          </list>When using OAuth access tokens, implementers MUST take
        into account the threats and countermeasures documented in the
        security considerations for the use of client authorizations (see
        Section 8 of <xref target="RFC7521" />). When using
        other token formats or frameworks, implementers MUST take into account
        similar threats and countermeasures, especially those documented by
        the relevant specifications.</t>
      </section>

    </section>
    <section anchor="Security" title="Security Considerations" toc="default">

      <section anchor="payloadAuthentication" title="Authentication Using Signed SETs">
	<t>In scenarios where HTTP authorization or TLS mutual authentication
	are not used or are considered weak, JWS signed SETs SHOULD be
	used (see <xref target="RFC7515"/> and Section 5 of <xref target="RFC8417"/>).
	This enables the SET Recipient
	to validate that the SET issuer is authorized to deliver the SET.
	</t>
      </section>
      <section title="HTTP Considerations">
        <t>SET delivery depends on the use of Hypertext Transfer Protocol and is thus
        subject to the security considerations of HTTP Section 9 of <xref
        target="RFC7230"/> and its related specifications.</t>

        <t>As stated in Section 2.7.1 of <xref target="RFC7230"/>, an
        HTTP requestor MUST NOT generate the <spanx style="verb">userinfo</spanx>
        (i.e., username and password) component (and its "@" delimiter) when
        an "http" URI reference is generated with a message, as they are now
        disallowed in HTTP.</t>
      </section>

      <section title="Confidentiality of SETs">
        <t>
	  SETs may contain sensitive information that is considered
	  Personally Identifiable Information (PII).
	  In such cases, SET Transmitters and
	  SET Recipients MUST protect the confidentiality of the SET contents by
	  encrypting the SET as described in JWE <xref target="RFC7516"/>,
	  using a transport-layer security mechanism such as TLS, or both. If
	  an Event delivery endpoint supports TLS, it MUST support at least TLS
	  version 1.2 <xref target="RFC5246"/> and SHOULD support the newest version
	  of TLS that meets its security requirements. When using TLS, the client MUST
	  perform a TLS/SSL server certificate check, per <xref target="RFC6125"/>.
	  Implementation security considerations for TLS can be found in
	  "Recommendations for Secure Use of TLS and DTLS" <xref target="RFC7525"/>.
	</t>
      </section>

      <section title="Access Token Considerations">
        <t>When using access tokens, such as those issued by OAuth 2.0
        <xref target="RFC6749"/>, implementers MUST take into account threats
        and countermeasures documented in Section 8 of <xref
        target="RFC7521"/>.</t>

        <section anchor="bearerConsiderations"
		 title="Bearer Token Considerations">
	  <t>Due to the possibility of interception, Bearer tokens MUST be
	  exchanged using TLS.</t>

	  <t>Bearer tokens MUST have a limited lifetime that can be determined
	  directly or indirectly (e.g., by checking with a validation service)
	  by the service provider. By expiring tokens, clients are forced to
	  obtain a new token (which usually involves re-authentication) for
	  continued authorized access. For example, in OAuth 2.0, a client MAY use
	  an OAuth refresh token to obtain a new bearer token after authenticating
	  to an authorization server, per Section 6 of <xref
	  target="RFC6749"/>.</t>

	  <t>Implementations supporting OAuth bearer tokens need to factor in
	  security considerations of this authorization method <xref
	  target="RFC7521"/>. Since security is only as good
	  as the weakest link, implementers also need to consider authentication
	  choices coupled with OAuth bearer tokens. The security considerations
	  of the default authentication method for OAuth bearer tokens, HTTP
	  BASIC, are well documented in <xref
	  target="RFC7617"/>, therefore implementers
	  are encouraged to prefer stronger authentication methods. Designating
	  the specific methods of authentication and authorization are
	  out of scope for the delivery of SETs, however this
	  information is provided as a resource to implementers.</t>
	</section>
      </section>


    </section>

    <section title="Privacy Considerations">

      <t>If a SET needs to be retained for audit purposes, a JWS signature MAY
      be used to provide verification of its authenticity.</t>

      <t>SET Transmitters SHOULD attempt to deliver SETs that are
      targeted to the specific business and
      protocol needs of subscribers.</t>

      <t>When sharing personally identifiable information or information
      that is otherwise considered confidential to affected users, SET
      Transmitters and Recipients MUST have the appropriate legal agreements
      and user consent or terms of service in place.</t>

      <t>The propagation of subject identifiers can be perceived as personally
      identifiable information. Where possible, SET Transmitters and Recipients
      SHOULD devise approaches that prevent propagation, for example, the
      passing of a hash value that requires the subscriber to already know
      the subject.</t>

    </section>

    <section anchor="IANA" title="IANA Considerations">

      <t>
	This specification requires no IANA actions.
      </t>

    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml' ?>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml' ?><!-- URI -->
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml' ?><!-- TLS 1.2 -->
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6125.xml' ?><!-- TLS Certs -->
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7231.xml' ?><!-- HTTP Semantics -->

      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7515.xml' ?><!-- JWS -->
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7516.xml' ?><!-- JWE -->
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7519.xml' ?><!-- JWT -->

      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7525.xml' ?><!-- TLS Recos -->
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml' ?><!-- RFC 2119 bis -->
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8259.xml' ?><!-- JSON -->
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8417.xml' ?><!-- SET -->

      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-secevent-http-push-06.xml" ?>
    </references>

    <references title="Informative References">
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3339.xml' ?>

      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6202.xml' ?><!-- HTTP Long Polling -->

      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6749.xml' ?><!-- OAuth -->
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6750.xml' ?><!-- OAuth Bearer-->

      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7521.xml' ?><!-- Client Auth Assertions -->

      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml' ?><!-- HTTP Msg -->
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7235.xml' ?><!-- HTTP Auth -->

      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7617.xml' ?><!-- Basic Auth Update -->

    </references>

    <section title="Acknowledgments">
      <t>The editors would like to thank the members of the SCIM working group, which
      began discussions of provisioning events starting with draft-hunt-scim-notify-00 in 2015.</t>

      <t>The editors would like to thank Phil Hunt and the other the authors of draft-ietf-secevent-delivery-02,
      on which this specification is based.</t>

      <t>The editors would like to thank the participants in the SecEvents
      working group for their contributions to this specification.</t>
    </section>

    <section anchor="History" title="Change Log">

      <t>[[ to be removed by the RFC Editor before publication as an RFC ]]</t>

      <t>
	Draft 00 - AB - Based on draft-ietf-secevent-delivery-02 with the
	following additions:
	<list style="symbols">
	  <t>Renamed to "Poll-Based SET Token Delivery Using HTTP"</t>
	  <t>Removed references to the HTTP Push delivery method.</t>
	</list>
      </t>
      <t>
	Draft 01 - mbj:
	<list style="symbols">
	  <t>
	    Addressed problems identified in my 18-Jul-18 review message titled
	    "Issues for both the Push and Poll Specs".
	  </t>
	  <t>
	    Changes to align terminology with RFC 8417, for instance,
	    by using the already defined term SET Recipient rather than SET Receiver.
	  </t>
	  <t>
	    Applied editorial and minor normative corrections.
	  </t>
	  <t>
	    Updated Marius' contact information.
	  </t>
	  <t>
	    Begun eliminating redundancies between this specification and
	    "Push-Based Security Event Token (SET) Delivery Using HTTP"
	    <xref target="I-D.ietf-secevent-http-push"/>,
	    referencing, rather that duplicating common normative text.
	  </t>
	</list>
      </t>
      <t>
	Draft 02 - mbj:
	<list style="symbols">
	  <t>
	    Removed vestigial language remaining from when the push and poll
	    delivery methods were defined in a common specification.
	  </t>
	  <t>
	    Replaced remaining uses of the terms Event Transmitter and Event Recipient
	    with the correct terms SET Transmitter and SET Recipient.
	  </t>
	  <t>
	    Removed uses of the unnecessary term "Event Stream".
	  </t>
	  <t>
	    Removed dependencies between the semantics of
	    <spanx style="verb">maxEvents</spanx> and <spanx style="verb">returnImmediately</spanx>.
	  </t>
	  <t>
	    Said that PII in SETs is to be encrypted with TLS, JWE, or both.
	  </t>
	  <t>
	    Corrected grammar and spelling errors.
	  </t>
	</list>
      </t>
      <t>
	Draft 03 - mbj:
	<list style="symbols">
	  <t>
	    Corrected uses of "attribute" to "member" when describing JSON objects.
	  </t>
	  <t>
	    Further alignment with the push draft.
	  </t>
	</list>
      </t>
    </section>
  </back>
</rfc>
